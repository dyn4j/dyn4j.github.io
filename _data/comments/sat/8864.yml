id: 8864
date: 2011-05-07 12:10:51 -0400
author: heishe
parent: sat
avatar: http://1.gravatar.com/avatar/15ca0d8471100d12247a315d66f91206?s=96&d=mm&r=g
message: "<p>Hi.</p>\n<p>First of all, thanks for the quick answer! That was very helpful and did exactly what I wanted. </p>\n<p>Still, one bug/problem seems to be left for me: The algorithm seems to have problems with edges which are not axis-aligned. It both doesn't detect correct collision occurrence and as a result of that it also produces wrong minimal translation vectors. </p>\n<p>I've searched for a long time now where the error in my code might be, but I just can't find it, so I guess I won't get around just posting my implementation here (it's in Java):</p>\n<p>The main algorithm is this:</p>\n<pre>public static Vector2f doCollideEx(Box a, Box b)\n	{		\n		Projection2D p1,p2;\n		float overlap = Float.MAX_VALUE;\n		Vector2f axis = new Vector2f(0.0f,0.0f);\n		\n		Vector2f[] edge_normals = a.getEdgeNormals();\n		for(int i=0;i<2;i++)\n		{\n			p1 = a.projectOnto(edge_normals[i]);\n			p2 = b.projectOnto(edge_normals[i]);\n			if(!p1.overlaps(p2))\n				return new Vector2f(0.0f,0.0f);\n			else\n			{\n				if(p1.getOverlap(p2)<overlap)\n				{\n					overlap = p1.getOverlap(p2);\n					axis = edge_normals[i];\n				}\n			}\n		}\n		\n		edge_normals = b.getEdgeNormals();\n		for(int i=0;i<2;i++)\n		{\n			p1 = a.projectOnto(edge_normals[i]);\n			p2 = b.projectOnto(edge_normals[i]);\n		\n			if(!p1.overlaps(p2))\n				return new Vector2f(0.0f,0.0f);\n			else\n			{\n				if(p1.getOverlap(p2)<overlap)\n				{\n					overlap = p1.getOverlap(p2);\n					axis = edge_normals[i];\n				}\n			}\n		}\n		\n		//test if translation vector is pointing away from box b\n		//and if so,  point the vector in its opposite direction\n		Vector2f ba = Vector2f.subtract(a.getCenter(), b.getCenter());\n		if(axis.dotProduct(ba) < 0.0f)\n			axis.negate();\n		\n		return Vector2f.multiply(axis,overlap);\n	}\n}</pre>\n<p>Just as a little sidenote: The reason I'm running \"i\" only through 0 and 1 is of course that I only need to check the first two axis.</p>\n<p>There are multiple custom classes used in that method, but I can assure you that all of them function correctly and produce correct values (I've tested them rigorously using various visualizations etc.). I also manually have to rotate the boxes when the user rotates them by a certain degree, but that code also works perfectly and produces correct values. </p>\n<p>I'm pretty sure that the error is somewhere in my code where I project a box onto an axis (as in a.projectOnto(axis)), although I have no idea what might be wrong about it. It's part of the \"Box\" class, which is basically your shape class, just simplified to be a box:</p>\n<pre>\n	public Projection2D projectOnto(Vector2f axis)\n	{\n		float min = Float.MAX_VALUE;\n		float max = Float.MIN_VALUE;\n		\n		for(int i=0;i max)\n				max = dot;\n			if(dot < min)\n				min = dot;\n		}\n		return new Projection2D(min,max);\n	}\n</pre>\n<p>Theoretically, my overlap code might also be producing values, but I have no idea how that could be:</p>\n<pre>\n	public boolean overlaps(Projection2D b)\n	{\n		return (!(b.right  this.right));\n	}\n	\n	public float getOverlap(Projection2D b)\n	{\n		return (this.right < b.right) ? this.right - b.left : b.right - this.left;\n	}\n</pre>\n<p>Sorry to bother you with lots of code, but I'm clueless right now and  don't know how to fix it.</p>"