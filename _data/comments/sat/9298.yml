id: 9298
date: 2015-02-03 10:40:11 -0500
author: Jerry
parent: sat
avatar: http://1.gravatar.com/avatar/1c73d107cf77da79183f5d687d8ba154?s=96&d=mm&r=g
message: "<p>Hello,</p>\n<p>And thank you for this great tutorial. However, I'm still having difficulties in implementing it.</p>\n<p><b>I'm getting the axes here:</b></p>\n<blockquote><p>\nVector[] axes = new Vector[shape.vertices.length];</p>\n<p>for (int i = 0; i < shape.vertices.length; i++)<br />\n{<br />\n    Vector p1 = shape.vertices[i];<br />\n    Vector p2 = shape.vertices[i + 1 == shape.vertices.length ? 0 : i + 1];</p>\n<p>    Vector normal = new Vector (p2.y &#8211; p1.y, -(p2.x &#8211; p1.x));<br />\n    axes[i] = normal;<br />\n}\n</p></blockquote>\n<p>The rectangle has an anti-clockwise winding.</p>\n<p><b>Checking the collision here:</b></p>\n<blockquote><p>\nAxis[] axes1 = shape1.getAxes();</p>\n<p>for (int i = 0; i < axes1.length; i++)<br />\n{<br />\n    Axis axis = axes1[i];</p>\n<p>    Projection p1 = shape1.project(axis);<br />\n    Projection p2 = shape2.project(axis);</p>\n<p>    if (!p1.overlap(p2))<br />\n    {<br />\n        return false;<br />\n    }<br />\n}</p>\n<p>return true;\n</p></blockquote>\n<p>Included only the first one.</p>\n<p><b>Projecting here:</b></p>\n<blockquote><p>\ndouble min = axis.dot(shape.vertices[0]);<br />\ndouble max = min;</p>\n<p>for (int i = 1; i < shape.vertices.length; i++)<br />\n{<br />\n    double p = axis.dot(shape.vertices[i]);  // How to normalize the axis?</p>\n<p>    if (p  max)<br />\n    {<br />\n        max = p;<br />\n    }<br />\n}</p>\n<p>Projection proj = new Projection(min, max);<br />\nreturn proj;\n</p></blockquote>\n<p><b>And getting the dot product here:</b></p>\n<blockquote><p>\nreturn point.x * axis.x + point.y * axis.y;\n</p></blockquote>\n<p>I feel like I'm missing something. For example, how do I normalize the axis when I'm getting the projection? Should I do some division somewhere? In case of getting the MTV.</p>\n<p>Jerry</p>"