id: 8933
date: 2013-03-10 05:08:37 -0400
author: jwilliams
parent: sat
avatar: http://0.gravatar.com/avatar/3dcdee8f416bcbe67ceae3a04e11d872?s=96&d=mm&r=g
message: "<p>William,</p>\n<p>Thank you for this article. It's been quite a help in trying to implement SAT.</p>\n<p>I've run into an issue in my implementation that I can't seem to figure out after 2 days banging my head on the keyboard here and am hoping you could shed some light on what is going on.</p>\n<p>Below is an image which depicts the issue. I am getting false positives on<br />\noverlap detection with shapes such as these, however something like a line,<br />\nsquare, rectangle etc. all work perfectly fine. The current position of the small box is as close as I am able to get to the nearest face without an overlap detection.</p>\n<p><a onclick=\"javascript:pageTracker._trackPageview('/outgoing/imgur.com/uaNVPks');\"  href=\"http://imgur.com/uaNVPks\" rel=\"nofollow\"></a></p>\n<p>Below is my current code for SAT detection in C#</p>\n<pre>\npublic static class SATHelper\n    {\n        struct Projection\n        {\n            public double Min;\n            public double Max;\n\n            public bool Overlaps(Projection other)\n            {\n                if (other.Min > this.Max ||\n                        this.Min > other.Max)\n                {\n                    return false;\n                }\n\n                return true;\n            }\n        }\n\n        public static bool Overlaps(VertexPositionColor[] anchor, VertexPositionColor[] other)\n        {\n            List anchorAxes = SATHelper.GetAxes(anchor);\n            List otherAxes = SATHelper.GetAxes(other);\n\n            for (int i = 0; i < anchorAxes.Count; i++)\n            {\n                Vector2 axis = anchorAxes[i];\n\n                //  project both shapes onto the axis\n                Projection anchorProjection = SATHelper.Project(axis, anchor);\n\n                Projection otherProjection = SATHelper.Project(axis, other);\n\n                if (!anchorProjection.Overlaps(otherProjection))\n                {\n                    return false;\n                }\n            }\n\n            for (int i = 0; i < otherAxes.Count; i++)\n            {\n                Vector2 axis = otherAxes[i];\n\n                //  project both shapes onto the axis\n                Projection anchorProjection = SATHelper.Project(axis, anchor);\n\n                Projection otherProjection = SATHelper.Project(axis, other);\n\n                if (!anchorProjection.Overlaps(otherProjection))\n                {\n                    return false;\n                }\n            }\n\n            Debug.WriteLine(&quot;Overlap &quot; + DateTime.Now.Millisecond);\n            return true;\n        }\n\n        private static Projection Project(Vector2 axis, VertexPositionColor[] vertices)\n        {\n            SATHelper.NormalizeVector(axis);\n\n            double min = GetDotProduct(axis, new Vector2(vertices[0].Position.X, vertices[0].Position.Y));\n            double max = min;\n\n            for (int i = 0; i < vertices.Length; i++)\n            {\n                double p = GetDotProduct(axis, new Vector2(vertices[i].Position.X, vertices[i].Position.Y));\n\n                if (p  max)\n                {\n                    max = p;\n                }\n            }\n\n            Projection projection = new Projection();\n            projection.Min = min;\n            projection.Max = max;\n\n            return projection;\n        }\n\n        private static void NormalizeVector(Vector2 vector)\n        {\n            if (float.IsNaN(vector.X) || float.IsNaN(vector.Y))\n            {\n                return;\n            }\n\n            float length = vector.Length();\n            vector.X /= length;\n            vector.Y /= length;\n        }    \n\n        private static double GetDotProduct(Vector2 v1, Vector2 v2)\n        {\n            double xDp = v1.X * v2.X;\n            double yDp = v1.Y * v2.Y;\n\n            return xDp + yDp;\n        }\n\n        //  returns normals for the shapes edges\n        private static List GetAxes(VertexPositionColor[] vertices)\n        {\n            List axes = new List();\n\n            for (int i = 0; i < vertices.Length; i++)\n            {\n                VertexPositionColor v1 = vertices[i];\n                Vector2 v1Vector = new Vector2(v1.Position.X, v1.Position.Y);\n\n                VertexPositionColor v2 = vertices[i + 1 == vertices.Length ? 0 : 1];\n                Vector2 v2Vector = new Vector2(v2.Position.X, v2.Position.Y);\n\n                Vector2 edge = v2Vector - v1Vector;\n\n                // This could cause problems later\n                Vector2 normal = new Vector2(-edge.Y, edge.X);\n\n                axes.Add(normal);\n            }\n\n            return axes;\n        }\n    }\n</pre>\n<p>Any help or insight into what may be causing the issue would be swell!</p>\n<p>Thanks,</p>\n<p>Justin</p>"