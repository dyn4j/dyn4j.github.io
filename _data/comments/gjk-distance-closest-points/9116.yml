id: 9116
date: 2014-01-02 12:51:55 -0500
author: William
parent: gjk-distance-closest-points
avatar: http://0.gravatar.com/avatar/9abfec71f4798ded76d242c8df48067e?s=96&d=mm&r=g
message: "<p>@John</p>\n<p>I'll try to summarize the major benefits of each, but this is by no means a complete list.  The tough part is that both are really good algorithms and really only have small benefits over one another.</p>\n<p><strong>SAT Pros:</strong><br />\n1. Very easy to implement and debug.<br />\n2. Returns collision normal and depth when a collision is detected.<br />\n3. Can be implemented on the GPU really easily (and will be extremely fast).<br />\n4. Really fast.<br />\n<strong>SAT Cons:</strong><br />\n1. Really only designed to work with polygons/polyhedra.  You can make it work for circular curves or just use polygonal approximations of curves.<br />\n2. In 3D you may end up tests a lot of axes in the collision case, especially if you end up approximating curved shapes (not really an issue for the GPU).<br />\n3. </p>\n<p><strong>GJK Pros:</strong><br />\n1. Very elegant implementation, for OOP especially.<br />\n2. With very minor code changes it can be used to return the distance between two convexes and their closest points.<br />\n3. Can handle any kind of convex shape, all that's required is a support function for it.<br />\n4. Really fast, even in the collision cases.<br />\n<strong>GJK Cons:</strong><br />\n1. Slightly harder to understand, implement and debug.<br />\n2. Harder to get numerically stable.<br />\n3. Requires a separate algorithm to return collision normal and depth when a collision is detected (EPA, sampling, etc.)<br />\n4. Not as easily transferable to the GPU due to the number of branches in the code.</p>\n<p>If you've already implemented one of these, I would just stick with it until the need arises where you need the other for some reason.<br />\nWilliam</p>"